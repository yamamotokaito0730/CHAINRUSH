/*=====
<FlyToCamera.cs>
└作成者：mori

＞内容
カメラに向かって飛んできて、一定距離になったら張り付く

＞注意事項


＞更新履歴
Y25         
_M05
__D  
___14:プログラム作成:mori
___15:カメラの振動呼び出し＆張り付き場所変更:yamamoto

=====*/
using System.Collections;
using UnityEngine;

public class FlyToCamera : MonoBehaviour
{
   // private UnityEngine.Camera mainCamera;
    private Camera mainCamera;

    /*＞StartFly関数
    引数：UnityEngine.Camera camera:メインのカメラ
    ｘ
    戻値：なし
    ｘ
    概要:外部から呼び出してカメラを設定し、処理を開始
    */
    public void StartFly(UnityEngine.Camera _camera)
    {

        mainCamera = _camera.GetComponent<Camera>();
        
        if (mainCamera != null)
        {
            // カメラに向かって飛ぶ＆張り付き処理開始
            StartCoroutine(FlyAndStick(_camera));
        }
        else
        {
            Debug.LogError("カメラが設定されていません");
        }
    }

    /*＞FlyAndStick関数
    引数：UnityEngine.Camera camera:メインのカメラ
    ｘ
    戻値：なし
    ｘ
    概要:カメラに向かって飛ぶ＆張り付き処理
    */
    private IEnumerator FlyAndStick(UnityEngine.Camera camera)
    {
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb == null) yield break;

        // 物理停止＆親子付け
        rb.isKinematic = true;
        transform.SetParent(camera.transform);

        Vector3 startLocalPos = camera.transform.InverseTransformPoint(transform.position);

        // ランダムなポジション設定
        //int randX = Random.Range(0, 2) * 2 - 1;
        //int randY = Random.Range(0, 2) * 2 - 1;
        float randX;
        float randY;
        do
        {
            randX = Random.Range(-1.0f, 1.0f);
            randY = Random.Range(-1.0f, 1.0f);
        } while (Mathf.Abs(randX) < 0.5f || Mathf.Abs(randY) < 0.5f); // 中心に近すぎる場合はやり直し

        Vector3 targetLocalPos = new Vector3(randX, randY, 2); // カメラ前方のローカル位置

        float duration = 0.3f;
        float t = 0.0f;

        while (t < 1.0f)
        {
            t += Time.deltaTime / duration;
            transform.localPosition = Vector3.Lerp(startLocalPos, targetLocalPos, t);
            yield return null;
        }
       mainCamera.ShakeCamera(0.1f, 0.3f);
        // 張り付いたまま1秒表示
        yield return new WaitForSeconds(0.5f);

        Destroy(gameObject);
    }
}
